// ROOT macro. Generates eventshape estimate by analyzing compiled glauber data.
// Settings for methods of edge extraction, energy density scaling can be set in config.h
// Assumes relevant MC Glauber data has been generated and compiled with compile_glauber.c

#include "../config.h"
#include "../utils/root_draw_tools.h"
#include "../utils/hist_tools.h"
#include "../utils/glauber_tools.h"

void eventshape_summary() {
  const double bmin = getImpactParameterFromCentralityClass(centralitybin_low,  sqrt_s, (char*) speciesA, (char*) speciesB);
  const double bmax = getImpactParameterFromCentralityClass(centralitybin_high, sqrt_s, (char*) speciesA, (char*) speciesB);
  
  // Attempt to open compiled data file generated by compile_glauber.c. Continue if successful.
  char species[5];
  snprintf(species, 5, "%s%s", speciesA, speciesB);
  char refstring[20];
  snprintf(refstring, 20, "b%.2f-%.2f",bmin,bmax);
  const char* infilename = Form("../data.nosync/%s_%.2fTeV/glauber/glauber_compiled_%s.root", species, sqrt_s, refstring);
  TFile *fin = new TFile(infilename);
  if (fin->IsZombie()) {
    std::cout << "Error in eventshape_summary.c:" << std::endl;
    std::cout << Form("Reference file (%s) does not exist!", infilename) << std::endl;
    std::cout << "Check specfied parameters, or run compile_glauber.c to generate this file." << std::endl;
    return;
  }
  
  // Open output file or create it if it doesn't exist.
  // Attempt to access relevant TTree, write data into new tree.
  // Somewhat inefficient with data handling, since TTree entries cannot be overwritten.
  // However, since we are limited to ~10 entries, this inefficiency is effectively harmless.
  double event_avg_area;
  double botcentbin_local;
  double topcentbin_local;
  TFile* datfile = new TFile(Form("../data.nosync/%s_%.2fTeV/eventshape_energyloss.root", species, sqrt_s), "update");
  TTree* eventshape_tree = new TTree("tempname", "eventshape_tree");
  eventshape_tree->Branch("centralitybin_low", &botcentbin_local);
  eventshape_tree->Branch("centralitybin_high", &topcentbin_local);
  eventshape_tree->Branch("eventshape_area", &event_avg_area);
  if (datfile->Get("eventshape_tree")) {
    // Outfile exists. Scan and discard previous data in the same centrality bin if applicable.
    TTreeReader* reader = new TTreeReader("eventshape_tree", datfile);
    TTreeReaderValue<Double_t> centreader_low(*reader, "centralitybin_low");
    TTreeReaderValue<Double_t> centreader_high(*reader, "centralitybin_high");
    TTreeReaderValue<Double_t> eventshape_reader(*reader, "eventshape_area");
    
    reader->Restart();
    while (reader->Next()) {
      if (*centreader_low == centralitybin_low &&
          *centreader_high == centralitybin_high) continue;
      event_avg_area = *eventshape_reader;
      botcentbin_local = *centreader_low;
      topcentbin_local = *centreader_high;
      eventshape_tree->Fill();
    }
  }
  
  // Set directory for output plots
  char outplot_dir[100];
  snprintf(outplot_dir, 100, "../plots/%s_%.2fTeV/glauber/centbin_%i-%i", species, sqrt_s, centralitybin_low, centralitybin_high);
  
  // Get data and compiled histograms from reference file.
  TVectorD gendata_Ntotal = *(TVectorD*) fin->Get("gendata_Ntotal");
  int nEvent = gendata_Ntotal[0];
  TH2D* refhist_shape[3];
  const char scaling_str[2][5] = {"arit", "geom"};
  const char alignstr[3][8] = {"noalign", "cmalign", "aligned"};
  const char alignstr_formal[3][25] = {"No Align", "CM Aligned", "CM, #Psi_{2} Aligned"};
  for (int i:{0,1,2}) refhist_shape[i] = static_cast<TH2D*> (fin->Get(Form("%s_eventshape_%s_%s",refstring,alignstr[i], scaling_str[isGeometric])));
  TH1D* refhist_gendata[3];
  refhist_gendata[0] = static_cast<TH1D*> (fin->Get(Form("%s_npart_hist",refstring)));
  refhist_gendata[1] = static_cast<TH1D*> (fin->Get(Form("%s_ncoll_hist",refstring)));
  refhist_gendata[2] = static_cast<TH1D*> (fin->Get(Form("%s_b_hist",refstring)));
  
  // TColor and TCanvas setup
  gStyle->SetOptStat(0);
  gStyle->SetPalette(kGreyScale);
  Int_t color_sample[12];
  for (int i = 0; i < 12; ++i) color_sample[i] = TColor::GetPalette().At(TColor::GetPalette().GetSize() * i/12);
  gStyle->SetPalette(kGreyYellow);
  Int_t color_bg = TColor::GetPalette().At(0);
  Int_t color_ongray[2] = {kRed+2, kAzure};
  
  TCanvas *doubleplot = new TCanvas();
  doubleplot->SetCanvasSize(1000, 500);
  doubleplot->SetMargin(0, 0, 0, 0);
  TPad* pads2[3];
  pads2[0] = buildPad("pad2_0", 0, .5, .5, 1, 0.1, 0.01, 0, 0.2, false);
  pads2[1] = buildPad("pad2_1", 0, 0, .5, .5, 0.1, 0.01, 0.2, 0, false);
  pads2[2] = buildPad("pad2_2", .5, 0, 1, 1, 0.15, 0.05, 0.1, 0.1, false);
  
  TCanvas *tripleplot = new TCanvas();
  tripleplot->SetCanvasSize(1000, 300);
  tripleplot->SetMargin(0, 0, 0, 0);
  TPad* pads3[3];
  pads3[0] = buildPad("pad3_0", 0, 0, 1./3, 1,      0.1, 0.15, 0.1, 0.1, false);
  pads3[1] = buildPad("pad3_1", 1./3, 0, 2./3, 1,   0.1, 0.15, 0.1, 0.1, false);
  pads3[2] = buildPad("pad3_2", 2./3, 0, 1, 1,      0.1, 0.15, 0.1, 0.1, false);
  pads3[0]->SetFrameFillColor(color_bg);
  pads3[1]->SetFrameFillColor(color_bg);
  pads3[2]->SetFrameFillColor(color_bg);
  
  TCanvas *harmonic_composite = new TCanvas();
  harmonic_composite->SetCanvasSize(1000, 500);
  harmonic_composite->SetMargin(0, 0, 0, 0);
  TPad* padsH[6];
  padsH[0] = buildPad("padH_0", 0.00, 0.475, 1./3, 0.950, 0.1, 0.05, 0, 0.1, false);
  padsH[1] = buildPad("padH_1", 0.00, 0.000, 1./3, 0.475, 0.1, 0.05, 0.1, 0, false);
  padsH[2] = buildPad("padH_2", 1./3, 0.475, 2./3, 0.950, 0.1, 0.05, 0, 0.1, false);
  padsH[3] = buildPad("padH_3", 1./3, 0.000, 2./3, 0.475, 0.1, 0.05, 0.1, 0, false);
  padsH[4] = buildPad("padH_4", 2./3, 0.475, 1.00, 0.950, 0.1, 0.05, 0, 0.1, false);
  padsH[5] = buildPad("padH_5", 2./3, 0.000, 1.00, 0.475, 0.1, 0.05, 0.1, 0, false);
  
  // Set up arrays, compute gradients of input hists, and prepare for averaging
  const int nSample_r = 100;
  double phidat[nSample_r];
  double rdat[3][2][nSample_r];
//  double xdat[3][2][nSample_r+1];
//  double ydat[3][2][nSample_r+1];
  TH2D* gradnorm[3];
  TH2D* gradnorm_polar[3];
  for (int i = 0; i < 3; ++i) {
    gradnorm[i] = gradientNorm(refhist_shape[i]);
    gradnorm_polar[i] = new TH2D(Form("gradnorm_polar_%s", alignstr[i]),
                                 ";Azimuth (#phi) [rad];r [fm];|#nablaE(x,y)| [a.u.]",
                                 nSample_r,-TMath::Pi(),TMath::Pi(),
                                 gradnorm[i]->GetXaxis()->GetNbins()/2,0,-gradnorm[i]->GetXaxis()->GetBinLowEdge(1));
  }
  
  // Setup for harmonics
  double meanr[3][2];
  double harmonic_x[3][2][5];
  double harmonic_y[3][2][5];
  TGraph* graph_r[3][2];
  TGraph* graph_r_onplot[3][2];
  TGraph* graph_harmonicfit[3][2][4];
  TMultiGraph* full_harmonics[3][2];
  TH1D* hist_coeffcients[3][2];
  
  
  // Loop and compute radial avg distance for each input hists
  for (int iRef = 0; iRef < 3; ++iRef) {
    // Loop over the three input reference hists
    
    //--------------------------------------------------------- Compute Edge r(phi)
    
    // Compute edge from grad-norm method
    double cr, cphi, csum, csum_r, val;
    for (int iPhi = 1; iPhi <= nSample_r; ++iPhi) {
      // Loop over azimuth for mean <r> in each azimuth bin
      cphi = gradnorm_polar[iRef]->GetXaxis()->GetBinCenter(iPhi);
      csum_r = 0;
      csum = 0;
      for (int ir = 1; ir <= gradnorm[iRef]->GetXaxis()->GetNbins()/2; ++ir) {
        // Loop for integration/averaging over radius
        cr = gradnorm_polar[iRef]->GetYaxis()->GetBinCenter(ir);
        val = gradnorm[iRef]->GetBinContent(gradnorm[iRef]->GetXaxis()->FindBin(cr*TMath::Cos(cphi)),
                                            gradnorm[iRef]->GetYaxis()->FindBin(cr*TMath::Sin(cphi)));
        
        // Add to weights for finding radial avg.
        // Note an extra factor of cr for cylindrical Jacobian.
        csum += cr * val;
        csum_r += cr * cr * val;
        gradnorm_polar[iRef]->Fill(cphi, cr, val);
      }// end of loop over radius
      
      // Store average radius at this azimuth
      rdat[iRef][0][iPhi-1] = csum_r/csum;
      if (iRef == 0) phidat[iPhi-1] = cphi;
    }// end of loop over azimuth
    
    // Compute edge from z-contour method
    double contour_zlevel = contour_z * refhist_shape[iRef]->GetMaximum();
    double val_next, r_prev;
    for (int iPhi = 0; iPhi < nSample_r; ++iPhi) {
      cphi = phidat[iPhi];
      // Loop over azimuth for r contour in each azimuth bin
      r_prev = 0;
      val = refhist_shape[iRef]->GetBinContent(refhist_shape[iRef]->GetXaxis()->FindBin(0.),
                                               refhist_shape[iRef]->GetYaxis()->FindBin(0.));
      for (int ir = 1; ir < refhist_shape[iRef]->GetXaxis()->GetNbins()/2; ++ir) {
        cr = gradnorm_polar[iRef]->GetYaxis()->GetBinCenter(ir);
        // loop over radius until a pair of bins is found that holds the contour
        val_next = refhist_shape[iRef]->GetBinContent(refhist_shape[iRef]->GetXaxis()->FindBin(cr*TMath::Cos(cphi)),
                                                      refhist_shape[iRef]->GetYaxis()->FindBin(cr*TMath::Sin(cphi)));
        if (val_next < contour_zlevel && val > contour_zlevel) break;
        
        // if no break, set last vals to current vals and iterate again.
        val = val_next;
        r_prev = cr;
      }
      
      // use the found bins to approximate the radial location of the contour
      // Uses local linear approximation from the boundary values
      rdat[iRef][1][iPhi] = (cr - r_prev)/(val_next - val) * (contour_zlevel - val) + r_prev;
    }
    
    //--------------------------------------------------------- Compute Harmonics
    
    hist_coeffcients[iRef][0] = new TH1D(Form("hist_harmoniccoefs_%s_gradnorm",alignstr[iRef]),
                                         ";Fourier Mode (n); Fourier Coefficient c_{n} = #sqrt{a_{n}^{2} + b_{n}^{2}}",5,1,6);
    hist_coeffcients[iRef][1] = new TH1D(Form("hist_harmoniccoefs_%s_contour",alignstr[iRef]),
                                         ";Fourier Mode (n); Fourier Coefficient c_{n} = #sqrt{a_{n}^{2} + b_{n}^{2}}",5,1,6);
    for (int iType = 0; iType < 2; ++iType) {
      // Compute mean <r(phi)> (zero-order harmonic)
      double cmean = 0;
      for (int iPhi = 0; iPhi < nSample_r; ++iPhi) cmean += rdat[iRef][iType][iPhi];
      meanr[iRef][iType] = cmean/nSample_r;
      
      // Compute harmonics
      double ca, cb;
      for (int iMode = 1; iMode <= 5; ++iMode) {
        ca = 0; cb = 0;
        for (int iPhi = 0; iPhi < nSample_r; ++iPhi) {
          ca += rdat[iRef][iType][iPhi] * TMath::Cos(iMode * phidat[iPhi]);
          cb += rdat[iRef][iType][iPhi] * TMath::Sin(iMode * phidat[iPhi]);
        }
//        std::cout << ca/(TMath::Pi()) << endl;
//        std::cout << cb/(TMath::Pi()) << endl;
        harmonic_x[iRef][iType][iMode-1] = 2*ca/(nSample_r);
        harmonic_y[iRef][iType][iMode-1] = 2*cb/(nSample_r);
        
        // Fill coef hist
        hist_coeffcients[iRef][iType]->SetBinContent(iMode, TMath::Sqrt(TMath::Power(harmonic_x[iRef][iType][iMode-1], 2)
                                                                + TMath::Power(harmonic_y[iRef][iType][iMode-1], 2)));
        hist_coeffcients[iRef][iType]->GetXaxis()->SetBinLabel(iMode, Form("%i",iMode));
      }
      
      // Make and store graphs of harmonic sum approximations
      double hdat[nSample_r];
      Int_t linestyle[4] = {1, 2, 5, 8};
      int color_idx[4] = {2, 4, 7, 9};
      int moderef[4][4] = {{1, 0, 0, 0},
                           {0, 1, 0, 0},
                           {0, 0, 1, 0},
                           {0, 0, 0, 1},};
      for (int iAppx = 0; iAppx < 4; ++ iAppx) {
        for (int iPhi = 0; iPhi < nSample_r; ++iPhi) {
          // Fill graph data
          hdat[iPhi] = meanr[iRef][iType]
            + moderef[iAppx][0] * (harmonic_x[iRef][iType][0] * TMath::Cos(1*phidat[iPhi])
                                    + harmonic_y[iRef][iType][0] * TMath::Sin(1*phidat[iPhi]))
            + moderef[iAppx][1] * (harmonic_x[iRef][iType][1] * TMath::Cos(2*phidat[iPhi])
                                    + harmonic_y[iRef][iType][1] * TMath::Sin(2*phidat[iPhi]))
            + moderef[iAppx][2] * (harmonic_x[iRef][iType][2] * TMath::Cos(3*phidat[iPhi])
                                    + harmonic_y[iRef][iType][2] * TMath::Sin(3*phidat[iPhi]))
            + moderef[iAppx][3] * (harmonic_x[iRef][iType][3] * TMath::Cos(4*phidat[iPhi])
                                    + harmonic_y[iRef][iType][3] * TMath::Sin(4*phidat[iPhi]));
        }
        // graph settings
        graph_harmonicfit[iRef][iType][iAppx] = new TGraph(nSample_r, phidat, hdat);
        graph_harmonicfit[iRef][iType][iAppx]->SetLineStyle(linestyle[iAppx]);
        graph_harmonicfit[iRef][iType][iAppx]->SetLineColor(color_sample[color_idx[iAppx]]);
      }
    }
    
    //--------------------------------------------------------- Non-composite level plots: Edge-finding
    
    // Make graphs for r(phi) display (edgefinding)
    for (int iType:{0,1}) {
      graph_r[iRef][iType] = new TGraph(nSample_r, phidat, rdat[iRef][iType]);
      graph_r[iRef][iType]->SetLineColor(color_ongray[iType]);
      
      double xdat[nSample_r+1];
      double ydat[nSample_r+1];
      for (int iPhi = 0; iPhi < nSample_r; ++iPhi) {
        xdat[iPhi] = rdat[iRef][iType][iPhi] * TMath::Cos(phidat[iPhi]);
        ydat[iPhi] = rdat[iRef][iType][iPhi] * TMath::Sin(phidat[iPhi]);
      }xdat[nSample_r] = xdat[0]; ydat[nSample_r] = ydat[0];
      
      graph_r_onplot[iRef][iType] = new TGraph(nSample_r+1, xdat, ydat);
      graph_r_onplot[iRef][iType]->SetLineColor(color_ongray[iType]);
    }
    
    // Plot r(phi) graphs over hists
    TLegend *leg = new TLegend(0.7, 0.7, 0.9, 0.95);
    leg->SetLineWidth(0);
    leg->SetFillColor(kGray);
    
    pads3[0]->cd();
    refhist_shape[iRef]->Draw("colz");
    graph_r_onplot[iRef][0]->SetLineStyle(3);
    graph_r_onplot[iRef][0]->Draw("l");
    graph_r_onplot[iRef][1]->Draw("l");
    leg->AddEntry(graph_r_onplot[iRef][0], "Gradient", "l");
    leg->AddEntry(graph_r_onplot[iRef][1], "Contour", "l");
    leg->Draw();
    
    pads3[1]->cd();
    gradnorm[iRef]->Draw("colz");
    graph_r_onplot[iRef][0]->SetLineStyle(1);
    graph_r_onplot[iRef][0]->Draw("l");
    
    pads3[2]->cd();
    gradnorm_polar[iRef]->Draw("colz");
    graph_r[iRef][0]->Draw("l");
    tripleplot->SaveAs(Form("%s/edgefind_%s_centbin_%i-%i.pdf", outplot_dir, alignstr[iRef], centralitybin_low, centralitybin_high));
    
    //--------------------------------------------------------- Non-composite level plots: Harmonics
    
    // Make plot of original graphs alongside approximations
    for (int iType = 0; iType < 2; ++iType) {
      full_harmonics[iRef][iType] = new TMultiGraph();
      full_harmonics[iRef][iType]->Add(graph_r[iRef][iType]);
//      for (int iAppx = 0; iAppx < 4; ++iAppx) full_harmonics[iRef][iType]->Add(graph_harmonicfit[iRef][iType][iAppx]);
      full_harmonics[iRef][iType]->Add(graph_harmonicfit[iRef][iType][1]);
      
      pads2[iType]->cd();
      full_harmonics[iRef][iType]->Draw("al");
      
      TLine* flatline = new TLine();
      flatline->SetLineColor(kGray);
      flatline->SetLineStyle(7);
      flatline->DrawLine(-TMath::Pi(), meanr[iRef][iType], TMath::Pi(), meanr[iRef][iType]);
      
      // Add fourier coefficient histograms
      hist_coeffcients[iRef][iType]->SetLineColor(color_ongray[iType]);
      hist_coeffcients[iRef][iType]->SetMarkerColor(color_ongray[iType]);
      hist_coeffcients[iRef][iType]->SetMarkerStyle(20);
      hist_coeffcients[iRef][iType]->SetFillColor(color_ongray[iType]);
      hist_coeffcients[iRef][iType]->SetBarOffset(0.1 + iType*0.4);
      hist_coeffcients[iRef][iType]->SetBarWidth(0.4);
      
      drawText(Form("#it{c}_{0} = %.4f", meanr[iRef][iType]), 0.13, 0.95 - !iType*0.2, false, kBlack, 0.05);
      drawText(Form("#it{c}_{2} = %.4f", hist_coeffcients[iRef][iType]->GetBinContent(2)), 0.13, 0.90 - !iType*0.2, false, kBlack, 0.05);
      if (!iType) drawText("Edge Extraction: Gradient-Averaging", 0.96, 0.95 - !iType*0.2, true, kBlack, 0.05);
      else        drawText(Form("Edge Extraction: z-Contour at %.2f", contour_z), 0.96, 0.95 - !iType*0.2, true, kBlack, 0.05);
    }// End of sketch for loop
    
    pads2[2]->cd();
    hist_coeffcients[iRef][0]->SetMaximum(1.2*getMaxFromHists(hist_coeffcients[iRef][0], hist_coeffcients[iRef][1]));
    hist_coeffcients[iRef][0]->Draw("b");
    hist_coeffcients[iRef][1]->Draw("b same");
    
    doubleplot->cd();
    TLatex *title_tex;
    if (isGeometric) title_tex = drawText(Form("Geometric Scaling (#sqrt{T_{A}T_{B}}), %s", 
                                               alignstr_formal[iRef]), 0.05, 0.92, false, kBlack, 0.03);
    else             title_tex = drawText(Form("Arithmetic Scaling (T_{A} + T_{B}), %s", 
                                               alignstr_formal[iRef]), 0.05, 0.92, false, kBlack, 0.03);
    if (iRef == 0) {
      drawText("Full Event Edge Harmonics", 0.05, 0.96);
      drawText(Form("#it{TGlauberMC} #bf{PbPb}, %i events", nEvent), 0.575, 0.92, false, kBlack, 0.03);
      drawText(Form("#it{b} #in [%.2f, %.2f]", bmin, bmax), 0.98, 0.95, true, kBlack, 0.03);
      drawText(Form("Centrality: %i-%i%%",centralitybin_low, centralitybin_high), 0.98, 0.92, true, kBlack, 0.03);
    }
    doubleplot->SaveAs(Form("%s/harmonics_%s_centbin%i-%i.pdf", outplot_dir, alignstr[iRef], centralitybin_low, centralitybin_high));
    title_tex->Clear();
  }// End of loop over reference hists
  
  //--------------------------------------------------------- Compute Event-Averaged Area
  
  event_avg_area = 0;
  double dr = 0.01;
  double dtheta = 2*TMath::Pi()/nSample_r;
  double cr;
  for (int iTheta = 0; iTheta < nSample_r; ++iTheta) {
    cr = 0;
    while (cr < rdat[ebe_alignmode][!gradnorm_edge][iTheta]) {
      event_avg_area += cr * dr * dtheta;
      cr += dr;
    }
  }
    
  // Write to tree
  botcentbin_local = centralitybin_low;
  topcentbin_local = centralitybin_high;
  eventshape_tree->Fill();
  eventshape_tree->Write("eventshape_tree", TObject::kOverwrite);

//
//  TF1* modes[5];
//  double ca, cb;
//  pads[0]->cd();
//  pads[0]->Clear();
//  modes[0]->Draw();
//  for (TF1* mode:modes) mode->Draw("same");
//  pads[1]->Clear();
//  pads[2]->Clear();
//  canvas->SaveAs("outplot_eventshape/harmonic_test.pdf");
//
//
//  // Overall event generation statistics summary
//
//  pads[0]->cd();
//  nPartHist->Draw("hist");
//  pads[1]->cd();
//  nCollHist->Draw("hist");
//  pads[2]->cd();
//  bHist->Draw("hist");
//  canvas->SaveAs("outplot_eventshape/event_hist_test.pdf");
  
  
  return;
}
