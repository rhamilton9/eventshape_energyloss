/// ROOT macro for generating a number of estimates related to event shape in simulated MC Glauber events
/// Expects events to be correctly aligned and averaged so as to align EBE CM and second-order event plante.
///
/// In particular, this method uses an extracted "edge" of glauber simulations to estimate the average transverse area
/// in a given centrality bin based on an averaged event computed in that centrality bin. For info on the generation,
/// alignment and averaging of these events, refer to the code for glauber generation in grace/readme.txt

#include "../config.h"
#include "../utils/root_draw_tools.h"
#include "../utils/hist_tools.h"
#include "../utils/glauber_tools.h"

// Boolean for producing plots of detected bad hists in varianceArea.
// This is usually helpful for debugging code which passes in bad histograms.
const bool doPlotBadHist = false;

Double_t varianceArea(TH2D* energy_density) {
  Double_t ctot_x = 0;
  Double_t ctot_y = 0;
  Double_t ctot_x2 = 0;
  Double_t ctot_y2 = 0;
  Double_t ctot_xy = 0;
  Double_t tot_weight = 0;
  Double_t cweight;
  TAxis* refaxis_x = energy_density->GetXaxis();
  TAxis* refaxis_y = energy_density->GetYaxis();
  for (Int_t ix = 1; ix <= refaxis_x->GetNbins(); ++ix) {
    for (Int_t iy = 1; iy <= refaxis_y->GetNbins(); ++iy) {
      cweight = energy_density->GetBinContent(ix, iy);
      ctot_x += cweight * refaxis_x->GetBinCenter(ix);
      ctot_y += cweight * refaxis_y->GetBinCenter(iy);
      ctot_x2 += cweight * refaxis_x->GetBinCenter(ix) * refaxis_x->GetBinCenter(ix);
      ctot_y2 += cweight * refaxis_y->GetBinCenter(iy) * refaxis_y->GetBinCenter(iy);
      ctot_xy += cweight * refaxis_x->GetBinCenter(ix) * refaxis_y->GetBinCenter(iy);
      tot_weight += cweight;
    }
  }
  Double_t sig_xx = (ctot_x2 - ctot_x*ctot_x/tot_weight);
  Double_t sig_yy = (ctot_y2 - ctot_y*ctot_y/tot_weight);
  Double_t sig_xy = (ctot_xy - ctot_x*ctot_y/tot_weight);
  Double_t area = 4*TMath::Pi() * TMath::Sqrt( (sig_xx * sig_yy - sig_xy * sig_xy) / (tot_weight*tot_weight));
  if (area > 200) {
    std::cout << "Error in <eventshape_summary::varianceArea>: Large area " << area << "fm found, which is likely an indication of a bad histogram." << std::endl;
    if (!doPlotBadHist) std::cout << "A plot of the input histogram can be saved to the desktop to check it. This option is currently off, but can be toggled in the global variables of eventshape_summary.c" << std::endl;
    else {
      TCanvas* c = new TCanvas();
      energy_density->Draw("colz");
      c->SetRightMargin(0.2);
      c->SaveAs(Form("~/Desktop/large_area.pdf"));
      delete c;
    }return 0;
  }return area;
}

void eventshape_summary() {
  // Attempt to open compiled data file generated by compile_glauber.c. Continue if successful.
  char species[5];
  char system_profile[15];
  char filename[100];
  snprintf(species, 5, "%s%s", speciesA, speciesB);
  snprintf(system_profile, 15, "%s%s%s%s", speciesA, profile_spec, speciesB, profile_spec);
  snprintf(filename, 100, "../data.nosync/%s_%.2fTeV/%s%.2fTeV_fullglauber.root",species,sqrt_s,system_profile,sqrt_s);
  TFile* glauber_file = new TFile(filename, "update");
  
  std::cout << "Input filename: " << filename << std::endl;
  
  // Set directory for output plots
  char outplot_dir[50];
  snprintf(outplot_dir, 50, "../plots/%s_%.2fTeV/glauber/", species, sqrt_s);
  
  // Global variables for use later
  const Int_t nevent = glauber_file->Get<TTree>("glauberTree")->GetBranch("b")->GetEntries();
  const Int_t ncent = sizeof(centrality_list) / sizeof(Int_t[2]);
  const Int_t nSample_r = 100;
  
  std::cout << "Check centrality bins against known reference:" << std::endl;
  
  // Use the established centrality from make_centrality.c
  TTree* centrality_tree = glauber_file->Get<TTree>("cent_tree");
  TTreeIndex* cent_index = new TTreeIndex(centrality_tree, "cent", "0");
  Long64_t* cent_sortedlist = cent_index->GetIndex(); // 100 entries (not memory intensive)
  Float_t b_cent;
  centrality_tree->SetBranchAddress("bcent", &b_cent);
  Float_t centbin_b[ncent+1]; centbin_b[0] = 0;
  for (Int_t iCent = 0; iCent < ncent; ++iCent) {
    centrality_tree->GetEntry(cent_index->GetEntryNumberWithIndex(centrality_list[iCent][1], 0));
    centbin_b[iCent+1] = b_cent;
    std::cout << Form("cent %i%%, b = %.5f",centrality_list[iCent][1], b_cent) << std::endl;
  }
  
  // Set up TTree for output
  const Int_t nAreaAlgo = 5;
  const Int_t nEdgeAlgo = 4;
  const char scaling_str[2][5] = {"arit", "geom"};
  const char algo_str[nAreaAlgo][10] = {"radmean", "grdmean", "gradmax", "halfmax", "phostat"};
  Int_t centbin[2];
  Float_t area_arit[nAreaAlgo];
  Float_t area_geom[nAreaAlgo];
  TTree* pheno_tree = new TTree("pheno_area_tree", "pheno_area_tree");
  pheno_tree->Branch("centbin_low", &centbin[0], "centbin_low/I");
  pheno_tree->Branch("centbin_high", &centbin[1], "centbin_high/I");
  for (Int_t iAlgo = 0; iAlgo < nAreaAlgo; ++iAlgo) {
    pheno_tree->Branch(Form("area_A_%s",algo_str[iAlgo]), &area_arit[iAlgo], Form("area_A_%s/F",algo_str[iAlgo]));
    pheno_tree->Branch(Form("area_G_%s",algo_str[iAlgo]), &area_geom[iAlgo], Form("area_G_%s/F",algo_str[iAlgo]));
  }
  
  // TColor Setup
  gStyle->SetOptStat(0);
  gStyle->SetPalette(kGreyYellow);
  Int_t color_sample[12];
  for (Int_t i = 0; i < 12; ++i) color_sample[i] = TColor::GetPalette().At(TColor::GetPalette().GetSize() * i/12);
  gStyle->SetPalette(kGreyYellow);
  Int_t color_bg = TColor::GetPalette().At(0);
  Int_t color_ongray[nEdgeAlgo] = {kBlue, kRed, kGreen, kMagenta};
  
  // Loop over centrality bins
  for (Int_t iCent = 0; iCent < ncent; ++iCent) {
    centbin[0] = centrality_list[iCent][0];
    centbin[1] = centrality_list[iCent][1];
    
    // Set up large canvas with certain subdivisions
    TCanvas *eventshape_canvas = new TCanvas("eventshape_canvas");
    eventshape_canvas->SetCanvasSize(1000, 850);
    TPad* bigpad[4];
    bigpad[0] = buildPad("bigpad0", 0, 12./19., 1, 18./19., 0, 0, 0, 0.2, false);
    bigpad[1] = buildPad("bigpad1", 0, 0, 0.5, 12./19.,     0, 0, 0, 0, false);
    bigpad[2] = buildPad("bigpad2", 0.5, 0, 1, 12./19.,     0, 0, 0, 0, false);
    bigpad[3] = buildPad("bigpad2", 0, 0, 1, 12./19.,       0, 0, 0, 0, true); // empty frame for text drawing
    
    bigpad[0]->cd();
    TPad* subpad0[3];
    subpad0[0] = buildPad("pad0_0", 0, 0, 1./3, 1,      0.1, 0.15, 0.1, 0.1, false);
    subpad0[1] = buildPad("pad0_1", 1./3, 0, 2./3, 1,   0.1, 0.15, 0.1, 0.1, false);
    subpad0[2] = buildPad("pad0_2", 2./3, 0, 1, 1,      0.1, 0.15, 0.1, 0.1, false);
    subpad0[0]->SetFrameFillColor(color_bg);
    subpad0[1]->SetFrameFillColor(color_bg);
    subpad0[2]->SetFrameFillColor(color_bg);
    
    bigpad[1]->cd();
    std::vector<std::vector<TPad*>> subpad1 = divideFlush(gPad, 1, 4, 0.1, 0.05, 0.07, 0.05);
    bigpad[2]->cd();
    std::vector<std::vector<TPad*>> subpad2 = divideFlush(gPad, 1, 2, 0.1, 0.05, 0.07, 0.05);
    
    // Set up arrays, compute gradients of input hists, and prepare for averaging
    TH2D* refhist_shape[2];
    refhist_shape[0] = glauber_file->Get<TH2D>(Form("avgEA_cent%i-%i_total",centbin[0],centbin[1]));
    refhist_shape[1] = glauber_file->Get<TH2D>(Form("avgEG_cent%i-%i_total",centbin[0],centbin[1]));
    
    Double_t phidat[nSample_r];
    Double_t rdat[2][nEdgeAlgo][nSample_r];
    TH2D* gradnorm[2];
    TH2D* gradnorm_polar[2];
    
    for (Int_t iScale = 0; iScale < 2; ++iScale) {
      refhist_shape[iScale]->GetZaxis()->SetTitle("E [GeV/fm^{2}];x [fm]; y[fm]");
      setStyleAxis(refhist_shape[iScale]->GetXaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(refhist_shape[iScale]->GetYaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(refhist_shape[iScale]->GetZaxis(), 0.045, 1.0, 0.04, 0.01);
      
      gradnorm[iScale] = gradientNorm(refhist_shape[iScale]); // Implemented in hist_tools.h
      gradnorm[iScale]->GetZaxis()->SetTitle("Norm(#nablaE(x,y)) [GeV/fm^{3}];x [fm];y [fm]");
      setStyleAxis(gradnorm[iScale]->GetXaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(gradnorm[iScale]->GetYaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(gradnorm[iScale]->GetZaxis(), 0.045, 1.0, 0.04, 0.01);
      
      gradnorm_polar[iScale] = new TH2D(Form("gradnorm_polar_%s_cent%i-%i", scaling_str[iScale], centbin[0], centbin[1]),
                                        ";Azimuth (#phi) [rad];r [fm];Norm(#nablaE(x,y)) [GeV/fm^{3}]",
                                        nSample_r,-TMath::Pi(),TMath::Pi(),
                                        gradnorm[iScale]->GetXaxis()->GetNbins()/2,0,-gradnorm[iScale]->GetXaxis()->GetBinLowEdge(1));
      setStyleAxis(gradnorm_polar[iScale]->GetXaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(gradnorm_polar[iScale]->GetYaxis(), 0.05, 0.8, 0.04, 0.01, 0.03, kWhite);
      setStyleAxis(gradnorm_polar[iScale]->GetZaxis(), 0.045, 1.0, 0.04, 0.01);
    }
    
    // Declaration of relevant TObjects to be used later
    Double_t meanr[nEdgeAlgo];                    // Data for the average radius (used for normalizing)
    Double_t harmonic_x[nEdgeAlgo][5];            // Data for the x sub-components of the series (Fourier cosine modes)
    Double_t harmonic_y[nEdgeAlgo][5];            // Data for the y sub-components of the series (Fourier sine modes)
    TGraph* graph_r[nEdgeAlgo];                   // The extracted edge as a function of azimuth
    TGraph* graph_r_onplot[nEdgeAlgo];            // For showing the extracted edge over the 2D distribution (i.e. polar plot of r(phi))
    TGraph* graph_harmonicfit[nEdgeAlgo][2];      // Show second and second+fourth degree harmonic fits (2 plots)
    TMultiGraph* display_harmonicfit[nEdgeAlgo];  // MultiGraph for the function with the fits displayed
    TH1D* hist_fourier_coefficients[nEdgeAlgo];   // Histogram of net fourier coefficients at each degree (1-6 displayed)
    TH1D* hist_fourier_normalized[nEdgeAlgo];     // Histogram of net fourier coefficients at each degree (1-6 displayed)
    
    // Extract the Glauber edge for each scaling and provide some summary plots of the results.
    for (Int_t iScale = 0; iScale < 2; ++iScale) {
      
      //--------------------------------------------------------- Compute Edge r(phi)
      
      // Compute edge from average radius (Algo 0)
      for (Int_t iPhi = 1; iPhi <= nSample_r; ++iPhi) {
        // Loop over azimuth for mean <r> in each azimuth bin
        Double_t cphi = gradnorm_polar[iScale]->GetXaxis()->GetBinCenter(iPhi);
        Double_t csum_r = 0;
        Double_t csum = 0;
        for (Int_t ir = 1; ir <= gradnorm[iScale]->GetXaxis()->GetNbins()/2; ++ir) {
          // Loop for integration/averaging over radius
          Double_t cr = gradnorm_polar[iScale]->GetYaxis()->GetBinCenter(ir);
          Double_t val = refhist_shape[iScale]->GetBinContent(refhist_shape[iScale]->GetXaxis()->FindBin(cr*TMath::Cos(cphi)),
                                                              refhist_shape[iScale]->GetYaxis()->FindBin(cr*TMath::Sin(cphi)));
          
          // Add to weights for finding radial avg.
          // Note an extra factor of cr for cylindrical Jacobian.
          csum += cr * val;
          csum_r += cr * cr * val;
        }// end of loop over radius
        
        // Store average radius at this azimuth
        if (csum_r/csum > 1e10) std::cout << "bad calc on avg rad at iPhi = " << iPhi-1 << std::endl;
        rdat[iScale][0][iPhi-1] = csum_r/csum;
        
        // Fill phidat on first iteration for later plotting
        if (iScale == 0) phidat[iPhi-1] = cphi;
      }// end of loop over azimuth
      
      // Compute edge from grad-norm average radius (Algo 1)
      for (Int_t iPhi = 1; iPhi <= nSample_r; ++iPhi) {
        // Loop over azimuth for mean <r> in each azimuth bin
        Double_t cphi = gradnorm_polar[iScale]->GetXaxis()->GetBinCenter(iPhi);
        Double_t csum_r = 0;
        Double_t csum = 0;
        for (Int_t ir = 1; ir <= gradnorm[iScale]->GetXaxis()->GetNbins()/2; ++ir) {
          // Loop for integration/averaging over radius
          Double_t cr = gradnorm_polar[iScale]->GetYaxis()->GetBinCenter(ir);
          Double_t val = gradnorm[iScale]->GetBinContent(gradnorm[iScale]->GetXaxis()->FindBin(cr*TMath::Cos(cphi)),
                                                         gradnorm[iScale]->GetYaxis()->FindBin(cr*TMath::Sin(cphi)));
          
          // Add to weights for finding radial avg.
          // Note an extra factor of cr for cylindrical Jacobian.
          csum += cr * val;
          csum_r += cr * cr * val;
          gradnorm_polar[iScale]->Fill(cphi, cr, val);
        }// end of loop over radius
        
        // Store average radius at this azimuth
        if (csum_r/csum > 1e10) std::cout << "bad calc on gradnorm at iPhi = " << iPhi-1 << std::endl;
        rdat[iScale][1][iPhi-1] = csum_r/csum;
      }// end of loop over azimuth
      
      // Compute edge from grad-norm max (Algo 2)
      for (Int_t iPhi = 1; iPhi <= gradnorm_polar[iScale]->GetXaxis()->GetNbins(); ++iPhi) {
        Int_t cmax_r_index = 0;
        for (Int_t ir = 1; ir <= gradnorm_polar[iScale]->GetYaxis()->GetNbins(); ++ir) {
          if (gradnorm_polar[iScale]->GetBinContent(iPhi, ir) >
              gradnorm_polar[iScale]->GetBinContent(iPhi, cmax_r_index))
            cmax_r_index = ir;
        }
        // Smooth sligthy by taking a wighted average ("CM") around the max point
        TAxis* refaxis_r = gradnorm_polar[iScale]->GetYaxis();
        Double_t csum = 0;
        Double_t csum_r = 0;
        for (Int_t iAvg = cmax_r_index - nsample_maxregion/2; iAvg <= cmax_r_index + nsample_maxregion/2; ++iAvg) {
          if (iAvg < 1 || iAvg > refaxis_r->GetNbins()) continue;
          Double_t val = gradnorm_polar[iScale]->GetBinContent(iPhi, iAvg);
          Double_t cr = refaxis_r->GetBinCenter(iAvg);
          csum_r += cr * cr * val;
          csum += cr*val;
        }rdat[iScale][2][iPhi-1] = csum_r / csum;
      }
      
      // Compute edge from z-contour method (Algo 3)
      Double_t contour_zlevel = 0.5 * refhist_shape[iScale]->GetMaximum();
      for (Int_t iPhi = 0; iPhi < nSample_r; ++iPhi) {
        Double_t cphi = phidat[iPhi];
        // Loop over azimuth for r contour in each azimuth bin
        Double_t r_prev = 0;
        Double_t val = refhist_shape[iScale]->GetBinContent(refhist_shape[iScale]->GetXaxis()->FindBin(0.),
                                                            refhist_shape[iScale]->GetYaxis()->FindBin(0.));
        
        Double_t val_next, cr;
        for (Int_t ir = 1; ir < refhist_shape[iScale]->GetXaxis()->GetNbins()/2; ++ir) {
          cr = gradnorm_polar[iScale]->GetYaxis()->GetBinCenter(ir);
          // loop over radius until a pair of bins is found that holds the contour
          val_next = refhist_shape[iScale]->GetBinContent(refhist_shape[iScale]->GetXaxis()->FindBin(cr*TMath::Cos(cphi)),
                                                          refhist_shape[iScale]->GetYaxis()->FindBin(cr*TMath::Sin(cphi)));
          if (val_next < contour_zlevel && val > contour_zlevel) break;
          
          // if no break, set last vals to current vals and iterate again.
          val = val_next;
          r_prev = cr;
        }// end of loop over radius
        
        // use the found bins to approximate the radial location of the contour
        // Uses local linear approximation from the boundary values
        rdat[iScale][3][iPhi] = (cr - r_prev)/(val_next - val) * (contour_zlevel - val) + r_prev;
        if (rdat[iScale][3][iPhi] > 1e10) std::cout << "bad calc on zcont at iPhi = " << iPhi << std::endl;
      }// end of loop over azimuth
      
      
      //--------------------------------------------------------- Compute Harmonics
      Double_t max_mode_all_hists[2] = {0,0};
      for (Int_t iAlgo = 0; iAlgo < nEdgeAlgo; ++iAlgo) {
        hist_fourier_coefficients[iAlgo] = new TH1D(Form("hist_harmoniccoefs_%s_cent%i-%i_%s",scaling_str[iScale],centbin[0],centbin[1],algo_str[iAlgo]),
                                                    ";Fourier Mode (n); Fourier Coefficient c_{n} = #sqrt{a_{n}^{2} + b_{n}^{2}}",5,1,6);
        hist_fourier_normalized[iAlgo] = new TH1D(Form("hist_harmonicnormed_%s_cent%i-%i_%s",scaling_str[iScale],centbin[0],centbin[1],algo_str[iAlgo]),
                                                  ";Fourier Mode (n); Normalized Fourier Coefficient c_{n}/c_{0}",5,1,6);
        
        std::cout << Form("%s scale, centbin %i-%i, algo %s harmonic modes:", scaling_str[iScale],
                          centbin[0], centbin[1], algo_str[iAlgo]) << std::endl;
        
        // Compute mean <r(phi)> (zero-order harmonic)
        Double_t cmean = 0;
        for (Int_t iPhi = 0; iPhi < nSample_r; ++iPhi) cmean += rdat[iScale][iAlgo][iPhi];
        meanr[iAlgo] = cmean/nSample_r;
        
        std::cout << Form("M0 = %.5f\t", meanr[iAlgo]);
        
        // Compute harmonics
        Double_t ca, cb;
        for (Int_t iMode = 1; iMode <= 5; ++iMode) {
          ca = 0; cb = 0;
          for (Int_t iPhi = 0; iPhi < nSample_r; ++iPhi) {
            ca += rdat[iScale][iAlgo][iPhi] * TMath::Cos(iMode * phidat[iPhi]);
            cb += rdat[iScale][iAlgo][iPhi] * TMath::Sin(iMode * phidat[iPhi]);
          }
          
          harmonic_x[iAlgo][iMode-1] = 2*ca/(nSample_r);
          harmonic_y[iAlgo][iMode-1] = 2*cb/(nSample_r);
          
          
          // Fill coef hist
          hist_fourier_coefficients[iAlgo]->SetBinContent(iMode, TMath::Sqrt(TMath::Power(harmonic_x[iAlgo][iMode-1], 2)
                                                                    + TMath::Power(harmonic_y[iAlgo][iMode-1], 2)));
          hist_fourier_coefficients[iAlgo]->GetXaxis()->SetBinLabel(iMode, Form("%i",iMode));
          
          hist_fourier_normalized[iAlgo]->SetBinContent(iMode, hist_fourier_coefficients[iAlgo]->GetBinContent(iMode) / meanr[iAlgo]);
          hist_fourier_normalized[iAlgo]->GetXaxis()->SetBinLabel(iMode, Form("%i",iMode));
          
          // Store max coef among all fits for plotting later
          if (hist_fourier_coefficients[iAlgo]->GetBinContent(iMode) > max_mode_all_hists[0])
            max_mode_all_hists[0] = hist_fourier_coefficients[iAlgo]->GetBinContent(iMode);
          if (hist_fourier_normalized[iAlgo]->GetBinContent(iMode) > max_mode_all_hists[1])
            max_mode_all_hists[1] = hist_fourier_normalized[iAlgo]->GetBinContent(iMode);
          
          std::cout << Form("M%i = %.5f\t", iMode, hist_fourier_coefficients[iAlgo]->GetBinContent(iMode));
        }std::cout << std::endl;
        
        // Make and store graphs of harmonic sum approximations
        Double_t hdat[nSample_r];
        Int_t linestyle[4] = {1, 5, 7, 8};
        Int_t color_idx[4] = {3, 7, 9, 11}; // Colors from an index of 12 from chosen TPalette
        // Could modify/include different types of fits to compare if e.g. there was nonzero v1
        // These toggle the modes in the fit display, with {v1, v2, v3, v4} for 4 fits
        Int_t moderef[4][4] = {
          {0, 1, 0, 1},
          {0, 1, 0, 0},
          {0, 0, 1, 0},
          {0, 0, 0, 1},};
        for (Int_t iAppx = 0; iAppx < 4; ++ iAppx) {
          for (Int_t iPhi = 0; iPhi < nSample_r; ++iPhi) {
            // Fill graph data
            hdat[iPhi] = (meanr[iAlgo]
                          + moderef[iAppx][0] * (harmonic_x[iAlgo][0] * TMath::Cos(1*phidat[iPhi])
                                                 + harmonic_y[iAlgo][0] * TMath::Sin(1*phidat[iPhi]))
                          + moderef[iAppx][1] * (harmonic_x[iAlgo][1] * TMath::Cos(2*phidat[iPhi])
                                                 + harmonic_y[iAlgo][1] * TMath::Sin(2*phidat[iPhi]))
                          + moderef[iAppx][2] * (harmonic_x[iAlgo][2] * TMath::Cos(3*phidat[iPhi])
                                                 + harmonic_y[iAlgo][2] * TMath::Sin(3*phidat[iPhi]))
                          + moderef[iAppx][3] * (harmonic_x[iAlgo][3] * TMath::Cos(4*phidat[iPhi])
                                                 + harmonic_y[iAlgo][3] * TMath::Sin(4*phidat[iPhi])) );
          }// End of loop over azimuth
           // graph settings
          graph_harmonicfit[iAlgo][iAppx] = new TGraph(nSample_r, phidat, hdat);
          graph_harmonicfit[iAlgo][iAppx]->SetLineStyle(linestyle[iAppx]);
          graph_harmonicfit[iAlgo][iAppx]->SetLineColor(color_sample[color_idx[iAppx]]);
        }// End of loop over approx
      }// End of loop over edge algo
      
      //--------------------------------------------------------- Non-composite level plots: Edge-finding
      
      // Make graphs for r(phi) display (edgefinding)
      for (Int_t iAlgo = 0; iAlgo < nEdgeAlgo; ++iAlgo) {
        graph_r[iAlgo] = new TGraph(nSample_r, phidat, rdat[iScale][iAlgo]);
        graph_r[iAlgo]->SetLineColor(color_ongray[iAlgo]);
        
        Double_t xdat[nSample_r+1];
        Double_t ydat[nSample_r+1];
        for (Int_t iPhi = 0; iPhi < nSample_r; ++iPhi) {
          xdat[iPhi] = rdat[iScale][iAlgo][iPhi] * TMath::Cos(phidat[iPhi]);
          ydat[iPhi] = rdat[iScale][iAlgo][iPhi] * TMath::Sin(phidat[iPhi]);
        }xdat[nSample_r] = xdat[0]; ydat[nSample_r] = ydat[0];
        
        graph_r_onplot[iAlgo] = new TGraph(nSample_r+1, xdat, ydat);
        graph_r_onplot[iAlgo]->SetLineColor(color_ongray[iAlgo]);
      }
      
      // Plot r(phi) graphs over 2D Energy/Gradient hists
      
      // Plot 1 (average energy density)
      subpad0[0]->cd();
      gPad->SetTicks(1,1);
      refhist_shape[iScale]->Draw("colz");
      graph_r_onplot[0]->Draw("l");
      graph_r_onplot[1]->Draw("l");
      graph_r_onplot[2]->Draw("l");
      graph_r_onplot[3]->Draw("l");

      // Plot 2 (average energy density gradient)
      subpad0[1]->cd();
      gPad->SetTicks(1,1);
      gradnorm[iScale]->Draw("colz");
      TMultiGraph* multigraph_polar = new TMultiGraph();
      multigraph_polar->Add(graph_r_onplot[1], "l");
      multigraph_polar->Add(graph_r_onplot[2], "l");
      multigraph_polar->Draw();
      
      // Plot 3 (energy density gradient unwound)
      subpad0[2]->cd();
      gPad->SetTicks(1,1);
      gradnorm_polar[iScale]->Draw("colz");
      TMultiGraph* multigraph_linear = new TMultiGraph();
      multigraph_linear->Add(graph_r[1], "l");
      multigraph_linear->Add(graph_r[2], "l");
      multigraph_linear->Draw();
      
      //--------------------------------------------------------- Non-composite level plots: Harmonics
      
      // Make plot of original graphs alongside approximations
      for (Int_t iAlgo = 0; iAlgo < nEdgeAlgo; ++iAlgo) {
        
        // Plot the radius curve alongside second and second+fourth harmonic fits
        display_harmonicfit[iAlgo] = new TMultiGraph();
        display_harmonicfit[iAlgo]->Add(graph_harmonicfit[iAlgo][0]);
        display_harmonicfit[iAlgo]->Add(graph_harmonicfit[iAlgo][1]);
        display_harmonicfit[iAlgo]->Add(graph_r[iAlgo]);
        display_harmonicfit[iAlgo]->SetTitle(";Azimuth #phi [rad]; r(#phi)");
        subpad1.at(iAlgo).at(0)->cd();
        gPad->SetTicks(1,1);
        double scalefactor = 1./(1. - gPad->GetBottomMargin() - gPad->GetTopMargin());
        setStyleAxis(display_harmonicfit[iAlgo]->GetXaxis(), 0.1, 1, 0.07, 0.02);
        setStyleAxis(display_harmonicfit[iAlgo]->GetYaxis(), 0.1/scalefactor, 0.35*scalefactor, 0.08/scalefactor, 0.005/scalefactor);
        display_harmonicfit[iAlgo]->GetYaxis()->SetNdivisions(310);
        display_harmonicfit[iAlgo]->Draw("al");
        
        // Average radius line
        TLine* flatline = new TLine();
        flatline->SetLineColor(kGray);
        flatline->SetLineStyle(7);
        flatline->DrawLine(-TMath::Pi(), meanr[iAlgo], TMath::Pi(), meanr[iAlgo]);
        
        // Text Info
        drawText(Form("#it{c}_{0} = %.4f", meanr[iAlgo]), 0.14, 0.9 - gPad->GetTopMargin(), false, kBlack, 0.1/scalefactor);
        drawText(Form("#it{c}_{2} = %.4f", hist_fourier_coefficients[iAlgo]->GetBinContent(2)), 0.14, 0.8 - gPad->GetTopMargin(), false, kBlack, 0.1/scalefactor);
        
        // Add fourier coefficient histograms
        hist_fourier_coefficients[iAlgo]->SetLineColor(color_ongray[iAlgo]+2);
        hist_fourier_coefficients[iAlgo]->SetMarkerColor(color_ongray[iAlgo]+2);
        hist_fourier_coefficients[iAlgo]->SetMarkerStyle(20);
        hist_fourier_coefficients[iAlgo]->SetFillColor(color_ongray[iAlgo]+2);
        hist_fourier_coefficients[iAlgo]->SetBarOffset(0.1 + iAlgo*0.2);
        hist_fourier_coefficients[iAlgo]->SetBarWidth(0.2);
        
        subpad2.at(0).at(0)->cd();
        gPad->SetTicks(1,1);
        if (iAlgo == 0) {
          hist_fourier_coefficients[iAlgo]->SetMaximum(1.1*max_mode_all_hists[0]);
          setStyleAxis(hist_fourier_coefficients[iAlgo]->GetYaxis(), 0.05, 1.05, 0.04, 0.005);
          hist_fourier_coefficients[iAlgo]->Draw("b");
        } else {
          hist_fourier_coefficients[iAlgo]->Draw("b same");
          std::cout << "Adding coef hist for iAlgo = " << iAlgo << ", max = " << hist_fourier_coefficients[iAlgo]->GetMaximum() << std::endl;
        }
        
        hist_fourier_normalized[iAlgo]->SetLineColor(color_ongray[iAlgo]+2);
        hist_fourier_normalized[iAlgo]->SetMarkerColor(color_ongray[iAlgo]+2);
        hist_fourier_normalized[iAlgo]->SetMarkerStyle(20);
        hist_fourier_normalized[iAlgo]->SetFillColor(color_ongray[iAlgo]+2);
        hist_fourier_normalized[iAlgo]->SetBarOffset(0.1 + iAlgo*0.2);
        hist_fourier_normalized[iAlgo]->SetBarWidth(0.2);
        
        subpad2.at(1).at(0)->cd();
        gPad->SetTicks(1,1);
        if (iAlgo == 0) {
          hist_fourier_normalized[iAlgo]->SetMaximum(1.1*max_mode_all_hists[1]);
          setStyleAxis(hist_fourier_normalized[iAlgo]->GetXaxis(), 0.05, 1.1, 0.06, 0.005);
          setStyleAxis(hist_fourier_normalized[iAlgo]->GetYaxis(), 0.05, 1.1, 0.04, 0.005);
          hist_fourier_normalized[iAlgo]->Draw("b");
        } else
          hist_fourier_normalized[iAlgo]->Draw("b same");
        
      }// End of sketch loop
      
      // Overall titles/labels
      subpad2.at(0).at(0)->cd();
      double legtop = 0.87;
      double legbot = 0.4;
      double legleft = 0.63;
      TLegend *leg_line = new TLegend(legleft, legbot, 0.9, legtop);
      leg_line->SetTextSize(0.04);
      leg_line->SetHeader("Edge Algo / Mode Fit");
      leg_line->SetLineWidth(0);
      leg_line->AddEntry(graph_r_onplot[0], "Radial Avg", "l");
      leg_line->AddEntry(graph_r_onplot[1], "Gradient Avg", "l");
      leg_line->AddEntry(graph_r_onplot[2], "Gradient Max", "l");
      leg_line->AddEntry(graph_r_onplot[3], Form("Contour z = %.1f",contour_z), "l");
      leg_line->AddEntry(graph_harmonicfit[0][0], "2nd Mode Fit", "l");
      leg_line->AddEntry(graph_harmonicfit[0][1], "2nd+4th Mode Fit", "l");
      leg_line->Draw();
      
//      TBox* leg_fill_box[4];
//      double pavespace = (legtop - legbot) / 6;
//      for (int iAlgo = 0; iAlgo < nEdgeAlgo; ++iAlgo) {
//        
//        leg_fill_box[iAlgo] = new TBox();
//        leg_fill_box[iAlgo]->SetFillStyle(1001);
//        leg_fill_box[iAlgo]->SetFillColor(color_ongray[iAlgo]);
//        leg_fill_box[iAlgo]->SetLineColor(color_ongray[iAlgo]);
//        std::cout << "left " << legleft - 0.05 << ", right " << legleft - 0.01 << ", top " << legtop - pavespace*(iAlgo) - 0.005 << ", bot "  << legtop - pavespace*(iAlgo+1) + 0.005 << std::endl;
//        leg_fill_box[iAlgo]->DrawBox(legleft - 0.05, legtop - pavespace*(iAlgo+1) + 0.005,
//                                     legleft - 0.01, legtop - pavespace*(iAlgo) - 0.005);
//        subpad2.at(1).at(0)->cd();
//        leg_fill_box[iAlgo]->DrawBox(0.1*iAlgo, 0.1, 0.9-0.1*iAlgo, 0.9);
//      }
      
      TLatex *title_tex;
      if (!iScale) {
        bigpad[3]->cd();
        drawText(Form("%i-%i%% Net Event Edge Harmonics",centbin[0], centbin[1]), 0.05, 0.965);
        
        eventshape_canvas->cd();
        title_tex = drawText("Arithmetic (E = (T_{A}+T_{B}))", 0.98, 0.97, true, kBlack, 0.03);
        drawText(Form("Eventshape Summary Sheet %i-%i%% Centrality",centbin[0], centbin[1]), 0.03, 0.96, false, kBlack, 0.04);
        drawText(Form("#it{TGlauberMC} #bf{PbPb} #sqrt{s_{NN}} = %.2f TeV, %i events", sqrt_s, nevent), 0.03, 0.93, false, kBlack, 0.03);
        drawText(Form("#it{b} #in [%.2f, %.2f]", centbin_b[iCent], centbin_b[iCent+1]), 0.98, 0.93, true, kBlack, 0.03);
        
      } else {
        eventshape_canvas->cd();
        title_tex = drawText("Geometric (E = #sqrt{T_{A}T_{B}})", 0.98, 0.96, true, kBlack, 0.03);
      }
      
      eventshape_canvas->SaveAs(Form("%s/centbin_%i-%i/eventshape_%s_centbin%i-%i.pdf", outplot_dir,
                                      centbin[0],centbin[1],
                                      scaling_str[iScale],centbin[0],centbin[1]));
      
      title_tex->Clear();
    }//End of loop over scalings
    std::cout << "Edge extraction complete for all methods. Proceeding to Area calculation..." << std::endl;
    //--------------------------------------------------------- Finished with Edge Extraction.
    
    //--------------------------------------------------------- Begin Area calculations
    
    std::cout << "A sample calc for each edge will be printed. These can be checked visually against the extracted edge." << std::endl;
    std::cout << Form("See <%s/edgefind_%s_centbin_%i-%i.pdf>", outplot_dir, scaling_str[1], centbin[0], centbin[1]) << std::endl;
    // Loop and compute radial avg distance for each input hists
    for (Int_t iAreaMethod = 0; iAreaMethod < nAreaAlgo; ++iAreaMethod) {
      
      // Loop over the possible energy scalings, averaging strategies
      for (Int_t iScale = 0; iScale < 2; ++iScale) {
        //--------------------------------------------------------- Compute Event-Averaged Area
        Double_t event_avg_area = 0;
        if (iAreaMethod == 4) { // Net statwidth area
          event_avg_area = varianceArea(refhist_shape[iScale]);
        } else { // Area from edge results
          Double_t dr = 0.01;
          Double_t cr;
          Double_t dtheta = 2*TMath::Pi()/nSample_r;
          for (Int_t iTheta = 0; iTheta < nSample_r; ++iTheta) {
            cr = 0;
            while (cr < rdat[iScale][iAreaMethod][iTheta]) {
              event_avg_area += cr * dr * dtheta;
              cr += dr;
              if (cr > 1e6) {std::cout << "possibly stuck in while with rdat = " << rdat[iScale][iAreaMethod][iTheta] << std::endl; break;}
            }
          }
        }
        
        switch (iScale) {
          case 0: // Arithmetic, no align
            area_arit[iAreaMethod] = event_avg_area;
            //            std::cout << area_arit[iAreaMethod] << std::endl;
            break;
          case 1: // Geometric, no align
            area_geom[iAreaMethod] = event_avg_area;
            //            std::cout << area_geom[iAreaMethod] << std::endl;
            break;
        }
      }//End of loop over scalings
    }// End of loop over area methods
    pheno_tree->Fill();
  }// End of loop over centrality bins
  
  // Write tree to file
  glauber_file->cd();
  pheno_tree->Print();
  pheno_tree->Write(pheno_tree->GetName(), TObject::kOverwrite);
  return;
}
